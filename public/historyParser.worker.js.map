{
  "version": 3,
  "sources": ["../lib/constants/browser.js", "../lib/browser-parser/queries.js", "../lib/browser-parser/processing.js", "../workers/history-parser/stats.js", "../workers/history-parser/index.js"],
  "sourcesContent": ["// Browser-related constants for parsing history databases\n\n// Query limit for browser history (worker processes in chunks so higher limit is OK)\nexport const QUERY_ROW_LIMIT = 500000;\n\n// Chunk size for streaming results from worker to main thread\nexport const WORKER_CHUNK_SIZE = 1000;\n\n// Chrome/Edge: Windows FILETIME epoch (microseconds since Jan 1, 1601)\nexport const CHROME_EPOCH_OFFSET = 11644473600000000;\n\n// Firefox: uses microseconds, divide by 1000 to get milliseconds\nexport const FIREFOX_PRECISION_DIVISOR = 1000;\n\n// Safari: Mac absolute time (seconds since Jan 1, 2001)\nexport const SAFARI_EPOCH_OFFSET = 978307200;\n\n// Browser name mappings\nexport const BROWSER_NAMES = new Map([\n  ['chrome', 'Chrome'],\n  ['firefox', 'Firefox'],\n  ['safari', 'Safari'],\n  ['edge', 'Edge'],\n  ['opera', 'Opera'],\n  ['brave', 'Brave'],\n  ['vivaldi', 'Vivaldi'],\n]);\n", "// Browser-specific SQL queries for parsing history databases\n// SINGLE SOURCE OF TRUTH - used by both lib/ and web worker\n\nimport { QUERY_ROW_LIMIT } from '../constants/browser';\n\nexport const BROWSER_QUERIES = {\n  firefox: {\n    downloads: `\n      SELECT\n        moz_places.last_visit_date AS lastVisitTime,\n        moz_places.url,\n        moz_places.title,\n        moz_annos.content AS eventEntity,\n        'File Name' AS eventEntityType,\n        'Download' AS eventType,\n        'Firefox' as browser\n      FROM\n        moz_places\n      JOIN\n        moz_annos ON moz_places.id = moz_annos.place_id\n      WHERE\n        moz_annos.content NOT LIKE '%deleted%'\n      ORDER BY moz_places.last_visit_date DESC\n      LIMIT ${QUERY_ROW_LIMIT}\n      `,\n    visits: `\n      SELECT\n          moz_historyvisits.visit_date as lastVisitTime,\n          moz_places.url,\n          moz_places.title,\n          moz_places.url as eventEntity,\n          'URL' AS eventEntityType,\n          'Visit' AS eventType,\n          'Firefox' as browser\n      FROM\n          moz_places\n      JOIN\n          moz_historyvisits ON moz_places.id = moz_historyvisits.place_id\n      ORDER BY moz_historyvisits.visit_date DESC\n      LIMIT ${QUERY_ROW_LIMIT}\n      `,\n    autofill: `\n      SELECT\n      moz_places.last_visit_date AS lastVisitTime,\n      moz_places.url,\n      moz_places.title,\n      moz_inputhistory.input AS eventEntity,\n      'Input' AS eventEntityType,\n      'Autofill' AS eventType,\n      'Firefox' as browser\n      FROM\n        moz_places\n      JOIN\n      moz_inputhistory ON moz_places.id = moz_inputhistory.place_id\n      ORDER BY moz_places.last_visit_date DESC\n      LIMIT ${QUERY_ROW_LIMIT}\n    `,\n    bookmarks: `\n      SELECT\n        moz_places.last_visit_date AS lastVisitTime,\n        moz_places.url,\n        moz_places.title,\n        moz_bookmarks.title AS eventEntity,\n        'Bookmark Name' AS eventEntityType,\n        'Bookmark' AS eventType,\n        'Firefox' as browser\n      FROM\n        moz_places\n      JOIN\n        moz_bookmarks ON moz_places.id = moz_bookmarks.fk\n      WHERE\n        moz_bookmarks.fk IS NOT NULL\n      ORDER BY moz_places.last_visit_date DESC\n      LIMIT ${QUERY_ROW_LIMIT}\n    `,\n  },\n  chrome: {\n    downloads: `\n      SELECT\n        start_time as lastVisitTime,\n        target_path as eventEntity,\n        tab_url as url,\n        tab_referrer_url as tabReferrerUrl,\n        referrer as referrer,\n        mime_type as mimeType,\n        original_mime_type as originalMimeType,\n        received_bytes as receivedBytes,\n        total_bytes as totalBytes,\n        'File Name' AS eventEntityType,\n        'Download' as eventType,\n        'Chrome' as browser\n      FROM\n        downloads\n      ORDER BY start_time DESC\n      LIMIT ${QUERY_ROW_LIMIT}\n    `,\n    visits: `\n    SELECT\n      visits.visit_time as lastVisitTime,\n      urls.url as url,\n      urls.title,\n      urls.url as eventEntity,\n      visits.external_referrer_url as referrer,\n      'URL' as eventEntityType,\n      'Visit' as eventType,\n      'Chrome' as browser\n    FROM\n      visits\n    JOIN\n      urls ON visits.url = urls.id\n    ORDER BY visits.visit_time DESC\n    LIMIT ${QUERY_ROW_LIMIT}\n    `,\n    keyword_search: `\n    SELECT\n      content_annotations.search_terms as eventEntity,\n      visits.visit_time as lastVisitTime,\n      urls.url,\n      urls.title,\n      'Keyword' as eventEntityType,\n      'Keyword' as eventType,\n      'Chrome' as browser\n    FROM\n      content_annotations\n    JOIN\n      visits ON content_annotations.visit_id = visits.id\n\t  JOIN\n      urls ON urls.id = visits.url\n    WHERE content_annotations.search_terms IS NOT \"\"\n    ORDER BY visits.visit_time DESC\n    LIMIT ${QUERY_ROW_LIMIT}\n    `,\n  },\n  safari: {\n    visits: `\n    SELECT\n      history_visits.visit_time as lastVisitTime,\n      history_items.url,\n      history_visits.title,\n      history_items.url as eventEntity,\n      history_visits.origin as referrer,\n      'URL' as eventEntityType,\n      'Visit' as eventType,\n      'Safari' as browser\n    FROM\n      history_visits\n    JOIN\n      history_items ON history_visits.history_item = history_items.id\n    ORDER BY history_visits.visit_time DESC\n    LIMIT ${QUERY_ROW_LIMIT}\n    `,\n  },\n};\n", "// Shared processing functions for browser history parsing\n// SINGLE SOURCE OF TRUTH - used by both lib/ and web worker\n\nimport {\n  CHROME_EPOCH_OFFSET,\n  FIREFOX_PRECISION_DIVISOR,\n  SAFARI_EPOCH_OFFSET,\n} from '../constants/browser';\n\n// Column mapping for standardized output\nexport const COLUMN_MAP = {\n  lastVisitTime: 'visitTime',\n  title: 'title',\n  eventType: 'eventType',\n  eventEntity: 'eventEntity',\n  browser: 'browser',\n  eventEntityType: 'eventEntityType',\n};\n\n/**\n * Extract hostname from URL\n */\nexport const urlToDomain = (url) => {\n  try {\n    return new URL(url).hostname;\n  } catch {\n    return 'Unknown';\n  }\n};\n\n/**\n * Extract apex domain from FQDN using PSL library\n * Note: psl must be available in the calling context (global in worker, imported in main thread)\n */\nexport const domainToApex = (domain, pslInstance = null) => {\n  if (domain === 'Unknown') return 'Unknown';\n\n  // Use provided psl instance or try global\n  const pslLib = pslInstance || (typeof psl !== 'undefined' ? psl : null);\n\n  if (pslLib) {\n    try {\n      const parsed = pslLib.parse(domain);\n      return parsed.domain || domain;\n    } catch {\n      // Fall through to fallback\n    }\n  }\n\n  // Fallback: return last two parts\n  const parts = domain.split('.');\n  return parts.length <= 2 ? domain : parts.slice(-2).join('.');\n};\n\n/**\n * Convert browser-specific timestamp to JavaScript milliseconds\n * Handles Chrome/Edge, Firefox, and Safari epoch differences\n */\nexport const processVisitTimestamp = (timestamp) => {\n  if (typeof timestamp !== 'number') {\n    return timestamp;\n  }\n\n  // Chrome/Edge: Windows FILETIME epoch (microseconds since Jan 1, 1601)\n  if (timestamp > CHROME_EPOCH_OFFSET) {\n    return (timestamp - CHROME_EPOCH_OFFSET) / 1000;\n  }\n\n  // Firefox: Unix timestamp in microseconds\n  if (timestamp > 1000000000000) {\n    return timestamp / FIREFOX_PRECISION_DIVISOR;\n  }\n\n  // Safari: Mac absolute time (seconds since Jan 1, 2001)\n  if (timestamp < 1000000000) {\n    return (timestamp + SAFARI_EPOCH_OFFSET) * 1000;\n  }\n\n  return timestamp;\n};\n\n/**\n * Format timestamp to locale string\n */\nexport const formatDate = (timestamp) => {\n  return new Date(timestamp).toLocaleString();\n};\n\n/**\n * Transform a raw database row into a standardized history object\n * @param {Array} row - Raw row values from SQL query\n * @param {Array} columns - Column names from SQL query\n * @param {Object} options - Optional configuration\n * @param {Function} options.onUrlStats - Callback to track URL/domain stats (for legacy processing.js compatibility)\n * @param {Object} options.psl - PSL library instance for apex domain parsing\n */\nexport const transformRow = (row, columns, options = {}) => {\n  const { onUrlStats, psl: pslInstance } = options;\n  const historyObject = { additionalFields: {} };\n\n  columns.forEach((column, index) => {\n    const value = row[index];\n\n    if (column === 'url') {\n      const domain = urlToDomain(value);\n      const apexDomain = domainToApex(domain, pslInstance);\n      historyObject.url = value;\n      historyObject.domain = domain;\n      historyObject.apexDomain = apexDomain;\n\n      // Call stats callback if provided (for legacy compatibility)\n      if (onUrlStats) {\n        onUrlStats(value, domain);\n      }\n    } else if (column === 'lastVisitTime') {\n      historyObject.visitTime = processVisitTimestamp(value);\n      historyObject.visitTimeFormatted = formatDate(historyObject.visitTime);\n    } else if (column === 'referrer' && value === '') {\n      return;\n    } else if (COLUMN_MAP[column]) {\n      historyObject[COLUMN_MAP[column]] = value;\n    } else {\n      historyObject.additionalFields[column] = value;\n    }\n  });\n\n  return historyObject;\n};\n", "// Worker-specific statistics calculation functions\n\n/**\n * Estimate total rows for progress calculation\n * @param {Object} db - SQL.js database instance\n */\nexport const estimateTotalRows = (db) => {\n  let total = 0;\n  const countQueries = [\n    'SELECT COUNT(*) FROM moz_historyvisits',\n    'SELECT COUNT(*) FROM visits',\n    'SELECT COUNT(*) FROM moz_places',\n    'SELECT COUNT(*) FROM urls',\n    'SELECT COUNT(*) FROM downloads',\n    'SELECT COUNT(*) FROM history_visits',\n  ];\n\n  for (const query of countQueries) {\n    try {\n      const result = db.exec(query)[0];\n      if (result && result.values[0]) {\n        total += result.values[0][0];\n      }\n    } catch {\n      // Table doesn't exist for this browser type\n    }\n  }\n\n  return Math.max(total, 100);\n};\n\n/**\n * Build statistics from all collected rows\n * @param {Array} allRows - Array of history objects\n */\nexport const buildStats = (allRows) => {\n  const urlStats = new Map();\n  const domainStats = new Map();\n  const apexDomainStats = new Map();\n\n  for (const row of allRows) {\n    const { url, domain, apexDomain, visitTime } = row;\n\n    // URL stats\n    if (!urlStats.has(url)) {\n      urlStats.set(url, {\n        count: 0,\n        first_visit: Infinity,\n        last_visit: 0,\n      });\n    }\n    const uStats = urlStats.get(url);\n    uStats.count++;\n    if (visitTime < uStats.first_visit) uStats.first_visit = visitTime;\n    if (visitTime > uStats.last_visit) uStats.last_visit = visitTime;\n\n    // Domain stats (FQDN)\n    if (!domainStats.has(domain)) {\n      domainStats.set(domain, {\n        count: 0,\n        first_visit: Infinity,\n        last_visit: 0,\n        unique_urls: new Set(),\n      });\n    }\n    const dStats = domainStats.get(domain);\n    dStats.count++;\n    dStats.unique_urls.add(url);\n    if (visitTime < dStats.first_visit) dStats.first_visit = visitTime;\n    if (visitTime > dStats.last_visit) dStats.last_visit = visitTime;\n\n    // Apex domain stats\n    if (!apexDomainStats.has(apexDomain)) {\n      apexDomainStats.set(apexDomain, {\n        count: 0,\n        first_visit: Infinity,\n        last_visit: 0,\n        unique_urls: new Set(),\n        unique_subdomains: new Set(),\n      });\n    }\n    const aStats = apexDomainStats.get(apexDomain);\n    aStats.count++;\n    aStats.unique_urls.add(url);\n    aStats.unique_subdomains.add(domain);\n    if (visitTime < aStats.first_visit) aStats.first_visit = visitTime;\n    if (visitTime > aStats.last_visit) aStats.last_visit = visitTime;\n  }\n\n  return { urlStats, domainStats, apexDomainStats };\n};\n\n/**\n * Attach stats to a row object\n * @param {Object} row - History object\n * @param {Map} urlStats - URL statistics map\n * @param {Map} domainStats - Domain statistics map\n * @param {Map} apexDomainStats - Apex domain statistics map\n */\nexport const attachStats = (row, urlStats, domainStats, apexDomainStats) => {\n  const uStats = urlStats.get(row.url);\n  const dStats = domainStats.get(row.domain);\n  const aStats = apexDomainStats.get(row.apexDomain);\n\n  row.url_count = uStats?.count || 0;\n  row.url_first_visit = uStats?.first_visit || null;\n  row.url_last_visit = uStats?.last_visit || null;\n  row.domain_count = dStats?.count || 0;\n  row.domain_first_visit = dStats?.first_visit || null;\n  row.domain_last_visit = dStats?.last_visit || null;\n  row.domain_unique_urls = dStats?.unique_urls?.size || 0;\n  row.apex_domain_count = aStats?.count || 0;\n  row.apex_domain_unique_urls = aStats?.unique_urls?.size || 0;\n  row.apex_domain_unique_subdomains = aStats?.unique_subdomains?.size || 0;\n\n  return row;\n};\n", "// Web Worker for parsing browser history SQLite files\n// This is the source file that gets bundled to public/historyParser.worker.js\n\nimport { WORKER_CHUNK_SIZE } from '../../lib/constants';\nimport { BROWSER_QUERIES, transformRow } from '../../lib/browser-parser';\nimport { estimateTotalRows, buildStats, attachStats } from './stats';\n\n// Global SQL instance\nlet SQL = null;\n\n// PSL library loaded flag\nlet pslLoaded = false;\n\nconst loadPsl = () => {\n  if (!pslLoaded) {\n    importScripts('https://cdn.jsdelivr.net/npm/psl@1.9.0/dist/psl.min.js');\n    pslLoaded = true;\n  }\n};\n\n// Main parsing function\nconst parseHistory = async (data, wasmUrl) => {\n  const uint8Array = data instanceof Uint8Array ? data : new Uint8Array(data);\n\n  try {\n    self.postMessage({\n      type: 'PROGRESS',\n      payload: { stage: 'init', message: 'Initializing database engine...', percent: 0 },\n    });\n\n    if (!SQL) {\n      importScripts('https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.13.0/sql-wasm.js');\n      SQL = await initSqlJs({\n        locateFile: () => wasmUrl,\n      });\n    }\n\n    // Load PSL library for apex domain parsing\n    loadPsl();\n\n    const db = new SQL.Database(uint8Array);\n\n    self.postMessage({\n      type: 'PROGRESS',\n      payload: { stage: 'counting', message: 'Analyzing database...', percent: 2 },\n    });\n\n    const totalRows = estimateTotalRows(db);\n\n    self.postMessage({\n      type: 'PROGRESS',\n      payload: {\n        stage: 'collecting',\n        message: 'Collecting history data...',\n        percent: 5,\n        totalRows,\n      },\n    });\n\n    // PASS 1: Collect all rows\n    const allRows = [];\n    let collectedRows = 0;\n\n    for (const [browserKey, queries] of Object.entries(BROWSER_QUERIES)) {\n      for (const [queryKey, query] of Object.entries(queries)) {\n        try {\n          const result = db.exec(query)[0];\n          if (result && result.values.length > 0) {\n            const { columns, values } = result;\n            for (const row of values) {\n              const transformed = transformRow(row, columns);\n              allRows.push(transformed);\n              collectedRows++;\n\n              // Update progress periodically\n              if (collectedRows % 5000 === 0) {\n                const progress = Math.min(45, 5 + Math.round((collectedRows / totalRows) * 40));\n                self.postMessage({\n                  type: 'PROGRESS',\n                  payload: {\n                    stage: 'collecting',\n                    message: 'Collecting history data...',\n                    percent: progress,\n                    processedRows: collectedRows,\n                    totalRows,\n                  },\n                });\n              }\n            }\n          }\n        } catch {\n          // Query failed for this browser type - continue with others\n        }\n      }\n    }\n\n    db.close();\n\n    self.postMessage({\n      type: 'PROGRESS',\n      payload: {\n        stage: 'stats',\n        message: 'Calculating statistics...',\n        percent: 50,\n        processedRows: collectedRows,\n        totalRows: collectedRows,\n      },\n    });\n\n    // Build statistics from all collected rows\n    const { urlStats, domainStats, apexDomainStats } = buildStats(allRows);\n\n    self.postMessage({\n      type: 'PROGRESS',\n      payload: {\n        stage: 'streaming',\n        message: 'Processing results...',\n        percent: 55,\n        processedRows: 0,\n        totalRows: allRows.length,\n      },\n    });\n\n    // PASS 2: Stream rows with stats attached\n    let streamedRows = 0;\n    let chunk = [];\n\n    for (const row of allRows) {\n      attachStats(row, urlStats, domainStats, apexDomainStats);\n      chunk.push(row);\n      streamedRows++;\n\n      if (chunk.length >= WORKER_CHUNK_SIZE) {\n        const progress = Math.min(99, 55 + Math.round((streamedRows / allRows.length) * 44));\n\n        self.postMessage({\n          type: 'CHUNK',\n          payload: {\n            items: chunk,\n            progress,\n            processedRows: streamedRows,\n            totalRows: allRows.length,\n          },\n        });\n\n        chunk = [];\n\n        // Yield to allow message processing\n        await new Promise((resolve) => setTimeout(resolve, 0));\n      }\n    }\n\n    // Send remaining items\n    if (chunk.length > 0) {\n      self.postMessage({\n        type: 'CHUNK',\n        payload: {\n          items: chunk,\n          progress: 99,\n          processedRows: streamedRows,\n          totalRows: allRows.length,\n        },\n      });\n    }\n\n    self.postMessage({\n      type: 'COMPLETE',\n      payload: { totalProcessed: streamedRows },\n    });\n  } catch (error) {\n    let message = error.message;\n\n    if (message.includes('not a database') || message.includes('file is not a database')) {\n      message = 'Invalid database file. Please upload a valid browser history file.';\n    } else if (message.includes('WASM')) {\n      message = 'Failed to load database engine. Please refresh and try again.';\n    }\n\n    self.postMessage({\n      type: 'ERROR',\n      payload: { message, stack: error.stack },\n    });\n  }\n};\n\n// Message handler\nself.onmessage = function(event) {\n  const { type, payload } = event.data;\n\n  if (type === 'PARSE_HISTORY') {\n    parseHistory(payload.data, payload.wasmUrl)\n      .catch(err => {\n        self.postMessage({\n          type: 'ERROR',\n          payload: { message: err.message, stack: err.stack },\n        });\n      });\n  } else if (type === 'CANCEL') {\n    // Cancellation not implemented yet\n  }\n};\n"],
  "mappings": "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",
  "names": []
}
